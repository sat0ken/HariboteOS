# 30日で出来るOS自作入門

## 0日目 開発を始める前に

- [x] はじめに
- [x] OSってなんだろう？
- [x] OSの作り方のいろいろ
- [x] 無知なら無知でいいじゃないか
- [x] OSを作るにはどうしたらいいの？
- [x] OSを作るときの苦労
- [x] １章以降を読むにあたって
- [x] 今後の話の流れ

- ソースを書く→Cコンパイラでコンパイル→イメージファイルを作る→ディスクに書き込む=OSがインストールされたディスクを作る  
　OSを作る=自動起動するOSが入ったディスクを作る
- (語りかけてくる感じが読みづらくてイラっとする)
- 自分が使っている言語がどういう機械語に翻訳されているか多少理解していないと、その言語でOSは作れない=せやね
- ソースがかっこよくても自分の期待する機械語になってくれないなら意味がない←草  
OS屋にとってソースなんて機械語を得るための手段であって目的ではない←かっけぇ...


## 1日目 PCの仕組みからアセンブラ入門まで

- [x] とにかくやるのだぁ

ddコマンドで`helloos.img`ファイルを作成
```
$ dd if=/dev/zero of=helloos.img bs=1474560 count=1
```

vimのバイナリモードで作成したファイルを開き編集

`:%!xxd` →`:%!xxd -r` 

qemuで起動する

```
$ qemu-system-i386 -fda helloos.img
```
popupで画面が出てhello worldが表示される

- [x] 結局何をやったのだろうか？

CPUには計算命令が備わっているが、電気信号じゃないと理解できない
電気信号に対してこの命令がきたら、その電気信号を出すように回路が組まれているだけ
0/1の信号を処理するだけ
コンパイルして機械語になったプログラムもCPUには電気信号で0/1の固まりとして送られる


- [x] アセンブラ初体験
- [x] もうちょっと書き直してみる

nasmアセンブラを書く

`sudo apt install nasm`で入れる
DB命令 = data byte, ファイルの内容を1byteだけ直接書く
RESB命令 = reserve byte, 指定したバイト数を確保して0x00で埋める

コンパイルする

```
$ nasm helloos1.nas -o helloos_from_nas.img
```

DW命令 = data word, 16bitなので2byte書き込み
DD命令 = data double word, 32bitなので4byte書き込み


## 2日目 アセンブラ学習とMakefile入門

- [x] まずはテキストエディタの紹介
terapadの紹介、Skip

- [x] さて開発再開

新しい命令
ORG = 機械語をロードするメモリ番地を指定
JMP = C言語でいうgoto
MOV = 代入, `MOV AX, 0` は `AX = 0;`を意味する

AX = アキュムレータ
CX = カウンタ
DX = データ
BX = ベース
SP = スタックポインタ(スタック用ポインタ)
BP = ベースポインタ(ベース用ポインタ)
SI = ソースインデックス(読み込みインデックス)
DI = ディスティネーションインデックス(書き込みインデックス)

8個のレジスタの合計は16バイト、CPUは16バイトしか記憶できない
32ビットになってもCPUは32バイトしか記憶できない

32bitのレジスタは以下
EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI

`JMP entry`は`JMP 0x7c50`と書いてもよい、0x7c50番地のプログラムに飛べという意味
アセンブラではラベルはただの数値、ORG命令から「このエントリはメモリのxx番地に読み込まれる」と計算してラベルの値となる

[SI]←[]でくくるとメモリを意味する
メモリはCPUからすると外部記憶装置
CPUが機械語を実行するときはメモリからプログラムを1命令ずつ読み出して順番に実行する
メモリはレジスタよりたくさん記憶できるがレジスタの何杯も遅い

`MOV BYTE [678], 123`
メモリの678番地に123を格納

`MOV WORD [678], 123`
WORDなので2バイト確保、678番地に`01111011`, 679番地に`00000000`が入る
→これがリトルエンディアンかー

ADDは足す、CMPは比較
JEは条件ジャンプ。

```
CMP AL, 0
JF fin
```

ALが0だったら、finにジャンプしろ

INTは割り込み、BIOSの関数を0x10で呼ぶ
HLTはCPU停止

- [x] ブートセクタだけを作るように整理
- [x] 今後のためにMakefile導入

## 3日目 32ビットモード突入とC言語導入 

- [x] さあ本当のIPLを作ろう

IPL=初期プログラムローダ

entryプログラムを以下のようにする

```
entry:
		MOV		AX,0			; レジスタ初期化
		MOV		SS,AX
		MOV		SP,0x7c00
		MOV		DS,AX

; ディスクを読む
		MOV		AX,0x0820
		MOV		ES,AX
		MOV		CH,0			; シリンダ0を指定
		MOV		DH,0			; ヘッド0を指定
		MOV		CL,2			; セクタ番号を指定
		MOV		AH,0x02			; ディスク読み込み
		MOV		AL,1			; 処理するセクタ数
		MOV		BX,0
		MOV		DL,0x00			; ドライブ番号を指定、Aドライブ
		INT		0x13			; ディスクBIOS呼び出し
		JC		err
```

JCは`jump if carry`の略、carryフラグが1だったらジャンプせよ

## 4日目 C言語と画面表示の練習

## 5日目 構造体と文字表示とGDT/IDT初期化

## 6日目 分割
















